
import { format } from 'date-fns';

export const backupService = {
  createBackup: async (router, data, operation = 'manual') => {
    const timestamp = new Date().toISOString();
    const backup = {
      id: Date.now(),
      routerId: router.id,
      routerName: router.name,
      timestamp,
      operation,
      data: {
        addressLists: data.addressLists || [],
        firewallRules: data.firewallRules || [],
        routerInfo: data.routerInfo || {},
      },
      size: JSON.stringify(data).length,
    };
    
    // In a real implementation, this would save to filesystem or database
    console.log('Creating backup:', backup);
    
    return new Promise((resolve) => {
      setTimeout(() => {
        resolve(backup);
      }, 500);
    });
  },

  getBackupHistory: async (routerId) => {
    // Mock backup history
    const mockBackups = [
      {
        id: 1,
        routerId,
        timestamp: new Date(Date.now() - 24 * 60 * 60 * 1000).toISOString(),
        operation: 'sync',
        size: 2048,
      },
      {
        id: 2,
        routerId,
        timestamp: new Date(Date.now() - 7 * 24 * 60 * 60 * 1000).toISOString(),
        operation: 'manual',
        size: 1856,
      }
    ];
    
    return new Promise((resolve) => {
      setTimeout(() => {
        resolve(mockBackups);
      }, 500);
    });
  },

  restoreFromBackup: async (router, backup) => {
    return new Promise((resolve) => {
      setTimeout(() => {
        resolve({
          success: true,
          message: 'Configurazione ripristinata con successo',
        });
      }, 2000);
    });
  },

  exportBackup: (backup, format = 'json') => {
    if (format === 'rsc') {
      return backupService.generateRSCScript(backup.data);
    }
    
    const dataStr = JSON.stringify(backup, null, 2);
    const dataBlob = new Blob([dataStr], { type: 'application/json' });
    const url = URL.createObjectURL(dataBlob);
    
    const link = document.createElement('a');
    link.href = url;
    link.download = `backup-${backup.routerName}-${format(new Date(backup.timestamp), 'yyyy-MM-dd-HH-mm')}.json`;
    link.click();
    
    URL.revokeObjectURL(url);
  },

  generateRSCScript: (data) => {
    let script = '# MikroTik RouterOS Script\n';
    script += '# Generated by MikroTik Address List Manager\n';
    script += `# Generated on: ${new Date().toISOString()}\n\n`;
    
    // Address Lists
    if (data.addressLists && data.addressLists.length > 0) {
      script += '# Address Lists\n';
      data.addressLists.forEach(item => {
        script += `/ip firewall address-list add`;
        script += ` list="${item.list}"`;
        script += ` address="${item.address}"`;
        if (item.comment) script += ` comment="${item.comment}"`;
        if (item.timeout) script += ` timeout="${item.timeout}"`;
        script += '\n';
      });
      script += '\n';
    }
    
    // Firewall Rules
    if (data.firewallRules && data.firewallRules.length > 0) {
      script += '# Firewall Rules\n';
      data.firewallRules.forEach(rule => {
        script += `/ip firewall filter add`;
        script += ` chain="${rule.chain}"`;
        script += ` action="${rule.action}"`;
        if (rule.srcAddress) script += ` src-address="${rule.srcAddress}"`;
        if (rule.srcAddressList) script += ` src-address-list="${rule.srcAddressList}"`;
        if (rule.dstPort) script += ` dst-port="${rule.dstPort}"`;
        if (rule.protocol) script += ` protocol="${rule.protocol}"`;
        if (rule.connectionState) script += ` connection-state="${rule.connectionState}"`;
        if (rule.comment) script += ` comment="${rule.comment}"`;
        if (rule.disabled) script += ` disabled=yes`;
        script += '\n';
      });
    }
    
    const dataBlob = new Blob([script], { type: 'text/plain' });
    const url = URL.createObjectURL(dataBlob);
    
    const link = document.createElement('a');
    link.href = url;
    link.download = `mikrotik-config-${format(new Date(), 'yyyy-MM-dd-HH-mm')}.rsc`;
    link.click();
    
    URL.revokeObjectURL(url);
    
    return script;
  },
};
